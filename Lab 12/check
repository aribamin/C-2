#!/usr/bin/env python3
# =============================================================================
# =========================== ENVIRONMENT VARIABLES ===========================
# =============================================================================
LAB_NB = 12

REQUIRED_FILES = [
    "ex12q1.c",
]

Q1_INPUT_1 = """\
p1 00010011111111111111000000000000
p1 10000000000000000000010000000000
p1 10001100101010000111110000101010
p1 01010000111110110000100101111110
"""

Q1_OUTPUT_1 = """\
0 00100 11111111111111000000000000
1 00000 00000000000000010000000000
1 00011 00101010000111110000101010
0 10100 00111110110000100101111110
"""

Q2_INPUT_1 = """\
p2 3.9
p2 4.1
p2 -0.8
"""

Q2_OUTPUT_1 = """\
0 10000 11110011001100110011010000
0 10001 00000110011001100110011000
1 01110 10011001100110011001101000
"""

Q3_INPUT_1 = """\
p3 00010011111111111111000000000000
p3 10000000000000000000010000000000
p3 10001100101010000111110000101010
p3 01010000111110110000100101111110
"""

Q3_OUTPUT_1 = """\
0.0009765
-0.0000000
-0.0002843
39.8449087
"""

Q4_INPUT_1 = """\
p4 double 3.2
p4 double 3.14
p4 add 3.4 -2.9
p4 add 3.14 3.14
p4 add 30.4 -3.4
"""

Q4_OUTPUT_1 = """\
6.4000001
6.2800002
0.5000000
6.2800002
26.9999995
"""

# =============================================================================
# ================================= FUNCTIONS =================================
# =============================================================================
import argparse
import os
import re
import tarfile
import tempfile
import shlex
import subprocess
import difflib
from pathlib import Path
from subprocess import Popen, PIPE, DEVNULL


def is_valid_host():
    """Checks to make sure we're running on a 201 lab machine"""
    hostname = subprocess.run("hostname", capture_output=True)

    if hostname.returncode != 0:
        print("Unexpected error when looking for hostname")
        return False

    hostname = hostname.stdout.decode(encoding="UTF-8").strip()

    return re.fullmatch("ug[0-9]{2}", hostname) or (
        hostname in ["ohaton", "coronation", "innisfree"]
    )


def take_diff(s1, s2, n1, n2):
    diffed = list(
        difflib.unified_diff(
            s1.split("\n"), s2.split("\n"), fromfile=n1, tofile=n2, lineterm="\n"
        )
    )
    diffed.insert(2, "@@ Additional/Missing tabs and spaces represented by █ @@")

    diffed = "\n".join(diffed)
    diffed = re.sub(rf"[ \t\r]+(\n|\Z)", r"█\g<1>", diffed)

    return diffed + "\n"


def gen_diff_with(student_out, our_out, name):
    s = f">>>> Diff for {name} >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> \n"
    s += take_diff(
        our_out,
        student_out,
        "Solution's output",
        "Student's output",
    )
    s += f"<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n"
    return s


def check_required_files(d):
    for f in REQUIRED_FILES:
        p = Path(f"{d}/{f}")

        if not p.is_file():
            print(f"File {f} missing from submission")
            exit(1)


def compile(l, o):
    s = ""
    for x in l:
        s += f"{x} "

    return (
        subprocess.run(shlex.split(f"gcc -Werror -Wall -std=c99 {s} -o {o}")).returncode
        == 0
    )


def run_test_1(executable, in_str, out_str, returncode, name):
    ex = Popen(executable, stdin=PIPE, stdout=PIPE, stderr=DEVNULL)

    try:
        ex_stdout, errs = ex.communicate(in_str.encode("utf-8"), timeout=1)
        ex_stdout = ex_stdout.decode("utf-8")
    except subprocess.TimeoutExpired:
        print(f"{name} did not exit under 1 second")
        exit(1)

    if ex.returncode != returncode:
        print(f"{name} failed to return code {returncode} when expected")
        exit(1)
    elif ex_stdout != out_str:
        print("Your output for part 1 doesn't match the solution")
        print(gen_diff_with(ex_stdout, out_str, name))
        exit(1)

def run_test_2(executable, in_str, out_str, returncode, name):
    ex = Popen(executable, stdin=PIPE, stdout=PIPE, stderr=DEVNULL)

    try:
        ex_stdout, errs = ex.communicate(in_str.encode("utf-8"), timeout=1)
        ex_stdout = ex_stdout.decode("utf-8")
    except subprocess.TimeoutExpired:
        print(f"{name} did not exit under 1 second")
        exit(1)

    if ex.returncode != returncode:
        print(f"{name} failed to return code {returncode} when expected")
        exit(1)
    elif ex_stdout != out_str:
        print("Your output for part 2 doesn't match the solution")
        print(gen_diff_with(ex_stdout, out_str, name))
        exit(1)

def run_test_3(executable, in_str, out_str, returncode, name):
    ex = Popen(executable, stdin=PIPE, stdout=PIPE, stderr=DEVNULL)

    try:
        ex_stdout, errs = ex.communicate(in_str.encode("utf-8"), timeout=1)
        ex_stdout = ex_stdout.decode("utf-8")
    except subprocess.TimeoutExpired:
        print(f"{name} did not exit under 1 second")
        exit(1)

    if ex.returncode != returncode:
        print(f"{name} failed to return code {returncode} when expected")
        exit(1)

    list_stdout = ex_stdout.split("\n")
    our_stdout = out_str.split("\n")

    for i in range(len(our_stdout)-1):
        if len(list_stdout) <= i:
            print(f"Your answer for part 3 had fewer ({len(list_stdout)}) lines than expected ({len(our_stdout)})")
            exit(1)

        try:
            f1 = round(float(our_stdout[i]), 6)
            f2 = round(float(list_stdout[i]), 6)

            if f1 != f2:
                print(f"For part 3, expected answer {f1} got {f2}")
                exit(1)
        except ValueError:
            print(f"Could not convert your line \"{list_stdout[i]}\" to a float for part 3")
            exit(1)

def run_test_4(executable, in_str, out_str, returncode, name):
    ex = Popen(executable, stdin=PIPE, stdout=PIPE, stderr=DEVNULL)

    try:
        ex_stdout, errs = ex.communicate(in_str.encode("utf-8"), timeout=1)
        ex_stdout = ex_stdout.decode("utf-8")
    except subprocess.TimeoutExpired:
        print(f"{name} did not exit under 1 second")
        exit(1)

    if ex.returncode != returncode:
        print(f"{name} failed to return code {returncode} when expected")
        exit(1)

    list_stdout = ex_stdout.split("\n")
    our_stdout = out_str.split("\n")

    for i in range(len(our_stdout)-1):
        if len(list_stdout) <= i:
            print(f"Your answer for part 4 had fewer ({len(list_stdout)}) lines than expected ({len(our_stdout)})")
            exit(1)

        try:
            f1 = round(float(our_stdout[i]), 6)
            f2 = round(float(list_stdout[i]), 6)

            if f1 != f2:
                print(f"For part 4, expected answer {f1} got {f2}")
                exit(1)
        except ValueError:
            print(f"Could not convert your line \"{list_stdout[i]}\" to a float for part 4")
            exit(1)

# =============================================================================
# =================================== MAIN ====================================
# =============================================================================
parser = argparse.ArgumentParser(
    prog=f"check",
    description=f"Check the core essentials for lab {LAB_NB}. Get 50% if you pass!",
)

parser.add_argument(
    "submission_tar",
    type=Path,
    metavar="<TAR>",
    help=f"Path to your submit.tar for lab {LAB_NB}",
)

args = parser.parse_args()


# Make sure it's the lab machine ====
if not is_valid_host():
    print(
        "This script must be run on the undergraduate lab machines, ug01 through ug34"
    )
    exit(1)

# Open tar ====
with tempfile.TemporaryDirectory() as tmpdir:
    try:
        with tarfile.open(args.submission_tar, "r") as f:
            f.extractall(path=tmpdir)
    except tarfile.ReadError:
        print(f"Provided path `{args.submission_tar}` is not a readable tar file")
        exit(1)

    check_required_files(tmpdir)

    if not compile([f"{tmpdir}/ex12q1.c"], f"{tmpdir}/ex12q1.out"):
        print(f"Failed to compile ex12q1.c!")
        exit(1)

    run_test_1(f"{tmpdir}/ex12q1.out", Q1_INPUT_1, Q1_OUTPUT_1, 0, "ex12q1.c")
    run_test_2(f"{tmpdir}/ex12q1.out", Q2_INPUT_1, Q2_OUTPUT_1, 0, "ex12q1.c")
    run_test_3(f"{tmpdir}/ex12q1.out", Q3_INPUT_1, Q3_OUTPUT_1, 0, "ex12q1.c")
    run_test_4(f"{tmpdir}/ex12q1.out", Q4_INPUT_1, Q4_OUTPUT_1, 0, "ex12q1.c")

print("Nice, you passed! You'll get at least 50% for this lab mark.")
